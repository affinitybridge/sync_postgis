<?php

// The key used for the postgis db in settings.php.
define('SYNC_POSTGIS_DB', 'sync_postgis');

/**
 * Implements hook_menu().
 */
function sync_postgis_menu() {
  $items = array();
  $items['admin/config/system/sync-postgis'] = array(
    'title' => 'Sync PostGis Settings',
    'description' => 'Control which content types get their geofields sync\'d.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sync_postgis_admin_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'sync_postgis.admin.inc',
  );
  //$items['admin/config/system/sync-postgis/db'] = array(
  //  'title' => 'Sync PostGis Database Set-up',
  //  'description' => 'Ensure there is a PostGIS database with a table for us to sync to.',
  //  'page callback' => 'drupal_get_form',
  //  'page arguments' => array('sync_postgis_check_db_form'),
  //  'access arguments' => array('administer site configuration'),
  //  'type' => MENU_LOCAL_ACTION,
  //  'file' => 'sync_postgis.admin.inc',
  //);
  $items['admin/config/system/sync-postgis/bulk'] = array(
    'title' => 'Bulk sync content to PostGIS',
    'description' => 'Goes through all geofield data that has been configured to be syncd to PostGIS and syncs it all using a job queue.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sync_postgis_bulk_sync'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'sync_postgis.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_node_presave().
 */
function sync_postgis_node_presave($node) {
  $fields = sync_postgis_get_geofields($node->type);
  if (!empty($fields)) {
    db_set_active(SYNC_POSTGIS_DB);
    $node->sync_postgis = array();
    foreach ($fields as $field_name) {
      sync_postgis_sync($node, $field_name);
    }
    db_set_active();
  }
}

/**
 * Syncs a node to the node table in the postgis db.
 */
function sync_postgis_sync(&$node, $field_name) {
  // Keep track of whether we have existing values for each field delta in the
  // postgis db.
  $existing = array();
  if ($node->nid) {
    $result = db_query("SELECT id, delta from {pg_node} WHERE nid = :nid AND field = :field", array(':nid' => $node->nid, ':field' => $field_name), array('fetch' => PDO::FETCH_ASSOC))->fetchAll();
    foreach ($result as $row) {
      $existing[$row['delta']] = $row['id'];
    }
  }
  $field = $node->{$field_name};
  $lang = $node->language;

  if (!empty($field[$lang][0]['wkt'])) {
    $node->sync_postgis[$field_name] = array();

    foreach ($field[$lang] as $delta => $item) {
      $wkt = $item['wkt'];

      if (empty($existing) || !isset($existing[$delta])) {
	// Build our insert query.
	$pg_query = 'INSERT INTO {pg_node} (nid, type, field, delta, title, geom, geom_albers) VALUES (';

	$pg_query .= $node->nid ? $node->nid . ", " : "NULL, ";
	$pg_query .= "'".$node->type."', '".$field_name."', '".$delta."', '".pg_escape_string($node->title)."', ";
	$pg_query .= "GeomFromText('" . $wkt . "', 4326)".", ";
	$pg_query .= "st_transform(GeomFromText('" . $wkt . "', 4326), 3005)";
	$pg_query .= ") RETURNING id;";

	try {
	  $result = db_query($pg_query);
	  try {
	    // Grab the last insert id from pg.
	    $pgid = db_query("SELECT currval('node_id_seq') FROM {pg_node}")->fetchField();
	  }
	  catch (Exception $e) {
	    watchdog_exception('sync_postgis', $e);
	  }
	}
	catch (Exception $e) {
	  watchdog_exception('sync_postgis', $e);
	}
      }
      else {
	// Update the record in postgis for this field value.
	$pg_query = "UPDATE {pg_node} SET title = '" .
	  pg_escape_string($node->title) . "', geom = " .
	  "GeomFromText('" . $wkt . "', 4326), geom_albers = " .
	  "st_transform(GeomFromText('" . $wkt . "', 4326), 3005)" .
	  " WHERE id = :id";
	db_query($pg_query, array(':id' => $existing[$delta]));
	$pgid = $existing[$delta];
      }
      if ($pgid) {
	$node->sync_postgis[$field_name][$delta] = $pgid;
      }
    }
  }
  else if (!empty($existing)) {
    // Delete existing records from the postgis db as the node no longer has
    // values for this field.
    foreach ($existing as $delta => $id) {
      db_query("DELETE from {pg_node} WHERE id = :id", array(':id' => $id));
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function sync_postgis_node_insert($node) {
  // Update the nid column in the postgis table.
  if ($node->sync_postgis && !empty($node->sync_postgis)) {
    db_set_active(SYNC_POSTGIS_DB);
    $ids = array();
    foreach($node->sync_postgis as $field_name => $values) {
      $ids = array_merge($ids, $values);
    }
    // Update the record in postgis for this field value.
    $pg_query = "UPDATE {pg_node} SET nid = :nid" .
		" WHERE id IN (" . implode(',', $ids) . ")";
    db_query($pg_query, array(':nid' => $node->nid));
    db_set_active();
  }
}

/**
 * Implements hook_node_delete().
 */
function sync_postgis_node_delete($node) {
  if (sync_postgis_test_db_connection()) {
    db_set_active(SYNC_POSTGIS_DB);
    // Delete the node record from the postgis table, if it exists.
    $pg_query = "DELETE FROM {pg_node} WHERE nid = :nid";
    try {
      db_query($pg_query, array(':nid' => $node->nid));
    }
    catch (Exception $e) {
      watchdog_exception('sync_postgis', $e);
    }
    db_set_active();
  }
}

/**
 * Gets and statically stores the list of geo fields per content type.
 */
function sync_postgis_get_geofields($type) {
  $fields = &drupal_static(__FUNCTION__, array());
  if (isset($fields[$type])) {
    return $fields[$type];
  }
  $fields[$type] = array_filter(variable_get('sync_postgis_enabled_' . $type, array()));
  return $fields[$type];
}

/**
 * Implements hook_cron_queue_info().
 */
function sync_postgis_cron_queue_info() {
  $queues['sync_postgis_queue'] = array(
    'worker callback' => 'sync_postgis_queue_process_item',
    'time' => 60,
  );
  return $queues;
}

/**
 * Syncs a single queued item.
 */
function sync_postgis_queue_process_item($item) {
  // Call whatever function will sync this item.
  if (isset($item['nid']) && is_numeric($item['nid'])) {
    // We just need to call node_save on the node in order to force it to get
    // syncd to the PostGIS db.
    $node = node_load($item['nid']);
    if ($node->nid && !$node->is_new) {
      node_save($node);
      drupal_set_message(t('Processed %title', array('%title' => $item['title'])));
    }
  }
}

/**
 * Implements hook_requirements().
 */
function sync_postgis_requirements($phase) {
  $requirements = array();
  if ($phase == 'runtime') {
    $requirements['sync_postgis'] = array(
      'title' => t('PostGIS Database'),
    );

    if (sync_postgis_test_db_connection()) {
      $requirements['sync_postgis']['severity'] = REQUIREMENT_OK;
      $requirements['sync_postgis']['value'] = t('Successfully connected to the PostGis Database');
    }
    else {
      $requirements['sync_postgis']['severity'] = REQUIREMENT_ERROR;
      $requirements['sync_postgis']['value'] = t('Could not connect to the PostGIS database. Make sure it has been added to your settings.php');
    }

  }

  return $requirements;
}

/**
 * Tests whether there's a postgis database set up that can be connected to.
 */
function sync_postgis_test_db_connection() {
  try {
    if ($db = Database::getConnection('default', SYNC_POSTGIS_DB)) {
      return TRUE;
    }
  }
  catch (Exception $e) {
    return FALSE;
  }
  return FALSE;
}